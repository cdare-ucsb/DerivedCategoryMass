<!DOCTYPE html>
<html lang="en">
  
<head>
    <title>Local P1</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

    <!-- <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}"> -->

     <!-- Load MathJax v3 with AMS package -->
     <script>
        window.MathJax = {
            loader: {load: ['[tex]/amscd']},
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],  // Allow inline LaTeX
                displayMath: [['$$', '$$'], ['\\[', '\\]']],  // Allow display LaTeX
                packages: {'[+]': ['amscd']}
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>

    <script type="text/javascript" async 
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

    

    <style>

        /* Styling the body */
        * {
            margin: 0px;
            padding: 0px;
        }

        /* Styling the first parallax's 
        height, width and background color */
        .parallax-1 {
            width: 100%;
            height: 800px;
            background: linear-gradient(135deg, #1a1a1a, #333333, #4d4d4d);
            animation: gradientAnimation 10s infinite alternate ease-in-out;
            background-size: 300% 300%;
            background-position: 0% 50%;

            display: flex;
            justify-content: center;  /* Centers child horizontally */
            align-items: center;  /* Centers child vertically */
            flex-direction: column; /* Ensures children are stacked */
            text-align: center; /* Centers text */
        }

        /* Gradient Animation */
        @keyframes gradientAnimation {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        /* Styling the title of first parallax */
        .parallax-1 h2 {
            margin: auto;
            position: relative;
            /* left: 500x;
            top: 300px;
            width: 250px;
            height: 32px; */
            padding: 10px;
            color: white;
            text-align: center;

            /* Fade-in effect */
            opacity: 0; /* Initially hidden */
            animation: fadeIn 1s ease-in-out forwards;
            animation-delay: 1s; /* Delay appearance by 1 second */
        }

        @keyframes fadeIn {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }

        /* Styling the second parallax's 
        height, width and background color */
        .parallax-2 {
            width: 100%;
            height: 600px;
            background: url("{{ url_for('static', filename='images/CY3fold.gif') }}") no-repeat center center fixed;
            background-size: 100% 100%;
            background-attachment: fixed;
        }

        /* Styling the title of second parallax */
        .parallax-2 h2 {
            margin: auto;
            position: relative;
            left: 500x;
            top: 300px;
            width: 250px;
            height: 37px;
            padding: 10px;
            background-color: white;
            text-align: center;
            font-size: 30px;
            font-family: Verdana;
        }

        /* Styling the second parallax's 
        height, width and background color */
        .parallax-3 {
            width: 100%;
            height: 550px;
            background: url("{{ url_for('static', filename='images/naive_local_P1.png') }}") center fixed;
            background-size: 100% 100%;
            background-attachment: fixed;
        }

        /* Styling the content or paragraph */
        .para-1 {
            padding: 50px;
            background-color: black;
            color: white;
            font-size: 17px;
        }

        /* Styling the content or paragraph */
        .para-2 {
            padding: 25px;
            font-size: 17px;
            background-color: black;
            color: white;
        }

        /* Styling the content or paragraph */
        .para-3 {
            padding: 25px;
            font-size: 17px;
            background-color: black;
            color: white;
        }

        /* Styling the content or paragraph */
        .para-4 {
            padding: 25px;
            font-size: 17px;
            background-color: black;
            color: white;
        }


        #page-2-content {
            /* position: fixed; */
            display: flex; /* Keeps elements inside aligned */
            justify-content: center;  /* Centers horizontally */
            align-items: center;  /* Centers vertically */
            max-width: 50%; /* Prevents it from being too large */
            width: fit-content; /* Shrinks wrapper to fit the image */
            height: fit-content;
            position: relative; /* Ensures it remains within normal flow */
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        /* Hidden image on page 5 */
        #page-5-content {
            display: flex; /* Keeps elements inside aligned */
            width: auto; /* Shrinks wrapper to fit the image */
            height: auto;
            justify-content: center;  /* Centers elements horizontally */
            align-items: center;  /* Aligns elements vertically */
            gap: 50px;  /* Adds 50px space between elements */
            
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        /* Initially position .container fully off-screen */
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 500px;
            max-width: 100%;
            box-sizing: border-box;
            margin: 0;
        }

        /* Initially position .container fully off-screen */
        .container-background {
            background: black;
            padding: 20px;
            width: fit-content; /* Shrinks wrapper to fit the image */
            height: fit-content;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 500px;
            box-sizing: border-box;
            margin: 0;
            display: flex;
            justify-content: center;
        }
        input, button {
            width: 30%;
            padding: 10px;
            font-size: 14px; /* Adjusts the font size */
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: #28a745;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #218838;
        }

        #switch-button {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: gray;
            color: white;
            border: none;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            width: auto; /* Let the button size itself based on text */
            min-width: fit-content; /* Ensures it is only as wide as the text */
            white-space: nowrap; /* Prevents text from wrapping */
            transition: transform 0.7s ease-in-out, opacity 0.8s ease-in-out;
        }

        #switch-button:hover {
            background-color: darkgray;
        }
    </style>
</head>

<body>

    <button id="switch-button" onclick="returnHome()" style="font-size: 20px;">Home</button>

    <!-- Giving title of the first parallax -->
    <div class="parallax-1">
        <h2>Local $\mathbb{P}^1$</h2>
    </div>

    <!--Content of first parallax -->
    <div class="para-1">
        <p>
            The extra dimensions that arise in string theory would need to be <emph>compact</emph> of a very tiny scale in order to avoid experimental detection; by additionally assuming that 
            the theory admits a supersymmetry, we are in fact imposing a strong geometric condition on the compactified target space.
            <br/>
            <br/>
            In order to have an unbroken $\mathcal{N} = 1$ supersymmetry
            in 4 spacetime dimensions, there must exist a spinor which is covariantly constant (i.e. unchanged under parallel transport). On complex threefolds, this is equivalent
            to the claim that the holonomy of the underlying target space is $SU(3)$ — in other words, the manifold is Calabi-Yau.
        </p>
    </div>

    <!-- Giving title of the first parallax -->
    <div class="parallax-2">
        
    </div>

    <!--Content of first parallax -->
    <div class="para-2">
        <p>
            A gauge field configuration is defined by a connection $A$ on a holomorphic vector bundle $E \to M$ over some complex manifold $M$. 
            In this setting, vacuum solutions correspond to gauge field configurations which minimize the Yang-Mills action 
            $$
            S_{\operatorname{YM}} = \int_M \operatorname{Tr}(F_A \wedge \ast F_A)
            $$ 
            In supersymmetric Yang-Mills theory, one can show that a minimum-energy configuration is achieved only when the connection $A$ is a Hermite-Einstein connection.
            By a theorem of Donaldson-Ulhenbeck-Yau, this is mathematically equivalent to the bundle $E$ being $\mu_H$-stable with respect to some Kähler class $H$. 
        </p>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <p id="page-2-text-cont">
            In string theory, objects depending on some choice of Kähler class are often modified by world-sheet instanton corrections. In this context, the vacuaa are described as BPS vacua and correspond to
            Bridgeland-stable objects in the derived category of our compactified dimensions (i.e. the Calabi-Yau threefold). Unfortunately, only one example of a complex compact Kahler threefold that admits
            geometric Bridgeland stability conditions is known (c.f. <a href="https://link.springer.com/article/10.1007/s00222-019-00888-z">Li (2019)</a>). One can simplify the problem by considering models with only  
            two compactified dimensions, so that much of the physics revolves around the study of K3 surfaces (<emph>plotted below</emph>). Unfortunately, the derived categories of projective K3 surfaces are still quite tedious due to a huge class
            of "spherical objects" whose automorphisms make up an infinite collection of intertwining braid groups. 
        </p>
    </div>

    <!--This will be same as first parallax-->
    <div class="parallax-1">
        <div id="page-2-content">
            <div id="plot_k3" style="width: 40vw;"></div>
        </div>
    </div>

    <div class="para-2">
        <p>
            To make things even simpler, one can consider a 'localized' model that resembles the derived category of a K3 surface in an open neighborhood of a rational curve. 
             Specifically, one considers the total space of the canonical bundle of such a rational curve
             $$
            \pi : X = \operatorname{Tot}(\omega_{\mathbb{P}^1}) \to \mathbb{P}^1
             $$
             which is a quasi-projective Calabi-Yau, and looks at the category $\mathcal{D}_0 \subset D^\flat(X)$ consisting of complexes whose cohomology sheaves are supported on
             the rational curve. This category now encodes the data of only a single braid group configuration in its automorphism group, generated by <emph>two</emph> "spherical objects".
        </p>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <p>
            From the results of  Macrì and Bridgelandand, the authors of <a href="https://www.semanticscholar.org/paper/THE-STABILITY-MANIFOLDS-OF-P-AND-LOCAL-P-Bertram-Marcus/fe8856ea9b25f1af622fffac0a22c1bfbf325b23">Bertram, Marcus, Wang, (2013)</a> showed that the stability conditions on Local $\mathbb{P}^1$ simply arise as spherical twists of the standard stability conditions on $\mathbb{P}^1$
             These stability conditions are quite simple to understand — the central charge is always of the form $Z_w = -\operatorname{ch}_1 + w \cdot \operatorname{ch}_0$, so that an open region of the stability manifold is simply constructed from the complex paramter $w \in \mathbb{C}$. It may be difficult to tell from the above widget, but at integer points on the real line, the central charge 
             of some $\mathcal{O}_{\mathbb{P}^1}(n)$ vanishes — thus, there are actually punctures at each integer point.
        </p>
    </div>

    <!-- Giving title of the first parallax -->
    <div class="parallax-1">
        <div id="page-3-content">
            <canvas id="xy-plane" width="500" height="500"></canvas>
        </div>  
    </div>

    <div class="para-3">
        <p id="page-4-text">
            It turns out that crossing any interval $(k-1, k)$ on the real line (where $k$ is an integer) causes point-like objects to destabilize, thus leading to a new chamber identical
             to our original upper half-plane obtained by applying an automorphism known as the spherical twist $\operatorname{Tw}_{i_\ast \mathcal{O}_k} $. Since $D^\flat(\mathbb{P}^1)$ is a constructible category, another miracle that occurs in the case of
            local projective space is that any spherical twist / wall crossing through $(k-1, k)$ is the same as applying some composition of spherical twists around $0$ and $-1$. This initially paints the picture given to the left
        </p>
        <br/>
        <br/>
        <br/>

        <p id="page-4-text-cont">
            However, using the identification $$\operatorname{Tw}_{i_\ast \mathcal{O}(-n)} \circ \dots \circ \operatorname{Tw}_{i_\ast \mathcal{O}} \{ i_\ast \mathcal{O}, i_\ast \mathcal{O}(-1)[1] \} = \{ i_\ast \mathcal{O}(-n), i_\ast \mathcal{O}(-n-1)[1] \}$$ it turns out that many
             of the chambers above glue together, leading to a much more complicated decomposition than the one shown below.
        </p>
    </div>



    
    <!-- Giving title of the first parallax -->
    <div class="parallax-3">
        
    </div>

    <div class="para-4">
        <p>
        There are methods of resolving the identification of chambers (e.g. using the kernel of the tiling action to define an inverse such as $\operatorname{Tw}_1$ to $\operatorname{Tw}_{-1}$); however, it turns out that finding the mass of a standard line bundle in the other chambers is the same as finding the mass of a spherical twist in the original geometric chamber $\Theta_0$. Thus, the first purpose of this program is to plot the mass of spherical objects in the chamber $\Theta_0$.
        </p>
    </div>

        <!-- Giving title of the first parallax -->
        <div class="parallax-1">
            <div id="page-5-content">
                <!-- The First Container (Initially Off-Screen) -->
                <div class="container-background">
                    <div class="container" id="first-container">
                        <h2 style="color: #4d4d4d;">Single Spherical Twist Computation</h2>
                        <p>Compute the mass of $\operatorname{Tw}_{i_\ast \mathcal{O}(a)} i_\ast \mathcal{O}(b)$, where</p>
                        <br/>
                        <form id="sph-twist-form" action="/plot_sph_twist_P1" method="POST">
                            <label for="line_bundle_1">First line bundle degree $a$ (integer):</label>
                            <input type="number" id="line_bundle_1" name="line_bundle_1" placeholder="e.g. -1" required>
                            <br/>
                            <label for="line_bundle_2">Second line bundle degree $b$ (integer):</label>
                            <input type="number" id="line_bundle_2" name="line_bundle_2" placeholder="e.g. 1" required>
                            <br/>
                            <button type="submit">Get Prediction</button>
                        </form>
                    </div> 
                </div>
    
                <!-- <div class="container-background">
                    <div class="container" id="second-container">
                        <h2 style="color: #4d4d4d;">Single Spherical Twist Computation</h2>
                        <p>Compute the mass of $\operatorname{Tw}_{i_\ast \mathcal{O}(a)} \operatorname{Tw}_{i_\ast \mathcal{O}(b)} i_\ast \mathcal{O}(c)$, where</p>
                        <br/>
                        <form id="double-twist-form" action="/plot_double_sph_twist_P1" method="POST">
                            <label for="line_bundle_1">First line bundle degree $a$:</label>
                            <input type="number" id="line_bundle_1" name="line_bundle_1" placeholder="e.g. -1" required>
                            <br/>
                            <label for="line_bundle_2">Second line bundle degree $b$:</label>
                            <input type="number" id="line_bundle_2" name="line_bundle_2" placeholder="e.g. 1" required>
                            <br/>
                            <label for="line_bundle_3">Third line bundle degree $c$:</label>
                            <input type="number" id="line_bundle_3" name="line_bundle_3" placeholder="e.g. 2" required>
                            <br/>
                            <button type="submit">Get Prediction</button>
                        </form>
                    </div> 
                </div> -->
            </div>
        </div>

</body>

<script>
    var k3_plot_json = {{ k3_plot_json | safe }};
    Plotly.newPlot('plot_k3', k3_plot_json.data, k3_plot_json.layout);

    document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('xy-plane');
            const ctx = canvas.getContext('2d');

            // Function to draw the x and y axes
            function drawAxes() {
                ctx.beginPath();
                ctx.moveTo(-canvas.width / 2, 0);
                ctx.lineTo(canvas.width / 2, 0);
                ctx.moveTo(0, -canvas.height / 2);
                ctx.lineTo(0, canvas.height / 2);
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Function to draw a circle at a given position
            function drawCircle(x, y, radius, color) {
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
            }

            // Initialize the canvas
            function initializeCanvas() {
                // Set up the coordinate system: move the origin to the center of the canvas
                ctx.translate(canvas.width / 2, canvas.height / 2);
                drawAxes();

                const step_size = canvas.height / 10;

                drawCircle(0,0, 0.1*step_size, 'gray');
                drawCircle(-1*step_size,0, 0.1*step_size, 'gray');
                drawCircle(1*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-2*step_size,0, 0.1*step_size, 'gray');
                drawCircle(2*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-4*step_size,0, 0.1*step_size, 'gray');
                drawCircle(4*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-5*step_size,0, 0.1*step_size, 'gray');
                drawCircle(5*step_size,0, 0.1*step_size, 'gray');

                

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-1*step_size, 0);
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.stroke();

                 // Draw the label
                 ctx.font = '16px Arial';
                ctx.fillStyle = 'blue';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('k(x)', -1.5*step_size, 0 );

            }

            // Function to clear the canvas and redraw the axes
            function clearCanvas() {
                // Clear the entire canvas
                ctx.clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);
                drawAxes();
            }

            // Function to draw a line from the origin to the clicked point
            function drawLineTo(x, y, label) {
                const step_size = canvas.height / 10;

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(x, y);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.stroke();

                 // Draw the label
                ctx.font = '16px Arial';
                ctx.fillStyle = 'red';
                ctx.textAlign = 'center';
                ctx.textBaseline = y > 0 ? 'bottom' : 'top';
                if (y > 0) {
                    ctx.fillText(label, x , y + 0.5*step_size);
                }
                else {
                    ctx.fillText(label, x , y - 0.5*step_size);
                }
                
            }

            

            // Event listener for mouse clicks
            canvas.addEventListener('click', (event) => {
                // Get the click position relative to the canvas
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left - canvas.width / 2;
                const y = event.clientY - rect.top - canvas.height / 2;

                const step_size = canvas.height / 10;

                // Clear the canvas, redraw the axes, and draw a line to the clicked point
                clearCanvas();

                
                drawLineTo(x, y, 'O');
                drawLineTo(x - step_size, y, 'O(-1)'); 
                drawLineTo(x + step_size, y, 'O(1)');
                drawLineTo(x-2*step_size, y, 'O(-2)');
                drawLineTo(x+2*step_size, y, 'O(2)');
                drawLineTo(x+3*step_size, y, 'O(3)');
                drawLineTo(x-3*step_size, y, 'O(-3)');
                drawLineTo(x-4*step_size, y, 'O(-4)');
                drawLineTo(x+4*step_size, y, 'O(4)');

                drawCircle(0,0, 0.1*step_size, 'gray');
                drawCircle(-1*step_size,0, 0.1*step_size, 'gray');
                drawCircle(1*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-2*step_size,0, 0.1*step_size, 'gray');
                drawCircle(2*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-4*step_size,0, 0.1*step_size, 'gray');
                drawCircle(4*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-5*step_size,0, 0.1*step_size, 'gray');
                drawCircle(5*step_size,0, 0.1*step_size, 'gray');

                

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-1*step_size, 0);
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.stroke();

                 // Draw the label
                 ctx.font = '16px Arial';
                ctx.fillStyle = 'blue';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('k(x)', -1.5*step_size, 0 );
            });

            // Initialize the canvas on page load
            initializeCanvas();
        });

        function returnHome() {
            window.location.href = "/"; // Redirect to Flask route
        }
</script>
  
</html>
