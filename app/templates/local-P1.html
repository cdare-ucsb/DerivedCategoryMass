<!DOCTYPE html>
<html lang="en">
  
<head>
    <title>Local P1</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

    <!-- <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}"> -->

     <!-- Load MathJax v3 with AMS package -->
     <script>
        window.MathJax = {
            loader: {load: ['[tex]/amscd']},
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],  // Allow inline LaTeX
                displayMath: [['$$', '$$'], ['\\[', '\\]']],  // Allow display LaTeX
                packages: {'[+]': ['amscd']}
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>

    <script type="text/javascript" async 
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>

    

    <style>

        /* Styling the body */
        * {
            margin: 0px;
            padding: 0px;
        }

        /* Styling the first parallax's 
        height, width and background color */
        .parallax-1 {
            width: 100%;
            height: 800px;
            background: linear-gradient(135deg, #1a1a1a, #333333, #4d4d4d);
            animation: gradientAnimation 10s infinite alternate ease-in-out;
            background-size: 300% 300%;
            background-position: 0% 50%;

            display: flex;
            justify-content: center;  /* Centers child horizontally */
            align-items: center;  /* Centers child vertically */
            flex-direction: column; /* Ensures children are stacked */
            text-align: center; /* Centers text */
        }

        /* Gradient Animation */
        @keyframes gradientAnimation {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        /* Styling the title of first parallax */
        .parallax-1 h2 {
            margin: auto;
            position: relative;
            /* left: 500x;
            top: 300px;
            width: 250px;
            height: 32px; */
            padding: 10px;
            color: white;
            text-align: center;

            /* Fade-in effect */
            opacity: 0; /* Initially hidden */
            animation: fadeIn 1s ease-in-out forwards;
            animation-delay: 1s; /* Delay appearance by 1 second */
        }

        @keyframes fadeIn {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }

        /* Styling the second parallax's 
        height, width and background color */
        .parallax-2 {
            width: 100%;
            height: 600px;
            background: url("{{ url_for('static', filename='images/CY3fold.gif') }}") no-repeat center center fixed;
            background-size: 100% 100%;
            background-attachment: fixed;
        }

        /* Styling the title of second parallax */
        .parallax-2 h2 {
            margin: auto;
            position: relative;
            left: 500x;
            top: 300px;
            width: 250px;
            height: 37px;
            padding: 10px;
            background-color: white;
            text-align: center;
            font-size: 30px;
            font-family: Verdana;
        }

        /* Styling the second parallax's 
        height, width and background color */
        .parallax-3 {
            width: 100%;
            height: 550px;
            background: url("{{ url_for('static', filename='images/naive_local_P1.png') }}") center fixed;
            background-size: 100% 100%;
            background-attachment: fixed;
        }

        /* Styling the content or paragraph */
        .para-1 {
            padding: 50px;
            background-color: black;
            color: white;
            font-size: 17px;
        }

        /* Styling the content or paragraph */
        .para-2 {
            padding: 25px;
            font-size: 17px;
            background-color: black;
            color: white;
        }

        /* Styling the content or paragraph */
        .para-3 {
            padding: 25px;
            font-size: 17px;
            background-color: black;
            color: white;
        }

        /* Styling the content or paragraph */
        .para-4 {
            padding: 25px;
            font-size: 17px;
            background-color: black;
            color: white;
        }

        .para-5 {
            padding: 25px;
            font-size: 17px;
            background-color: black;
            color: white;
        }

        .para-6 {
            padding: 25px;
            font-size: 17px;
            background-color: black;
            color: white;
        }



        #page-2-content {
            /* position: fixed; */
            display: flex; /* Keeps elements inside aligned */
            justify-content: center;  /* Centers horizontally */
            align-items: center;  /* Centers vertically */
            max-width: 50%; /* Prevents it from being too large */
            width: fit-content; /* Shrinks wrapper to fit the image */
            height: fit-content;
            position: relative; /* Ensures it remains within normal flow */
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        /* Hidden image on page 5 */
        #page-5-content {
            display: flex; /* Keeps elements inside aligned */
            width: auto; /* Shrinks wrapper to fit the image */
            height: auto;
            justify-content: center;  /* Centers elements horizontally */
            align-items: center;  /* Aligns elements vertically */
            gap: 50px;  /* Adds 50px space between elements */
            
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        #page-7-content {
            width: 45%;  /* Make each div take up 45% of the screen */
            min-width: 300px;  /* Prevents divs from collapsing */
        }

        #page-9-and-10-container {
            display: flex;  /* Enables horizontal row layout */
            flex-direction: row;  /* Explicitly set row direction */
            justify-content: center;  /* Centers the divs */
            align-items: flex-start;  /* Aligns them to the top */

            gap: 40px;  /* Adds spacing between them */
            width: 100%;  /* Ensures it spans the full width */
        }

        #page-10-content {
            /* position: fixed; */
            display: none; /* Keeps elements inside aligned */
            justify-content: center;  /* Centers horizontally */
            align-items: center;  /* Centers vertically */
            max-width: 50%; /* Prevents it from being too large */
            width: fit-content; /* Shrinks wrapper to fit the image */
            height: fit-content;
            position: relative; /* Ensures it remains within normal flow */
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        /* Initially position .container fully off-screen */
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 500px;
            max-width: 100%;
            box-sizing: border-box;
            margin: 0;
        }

        /* Initially position .container fully off-screen */
        .container-background {
            background: black;
            padding: 20px;
            width: fit-content; /* Shrinks wrapper to fit the image */
            height: fit-content;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 500px;
            box-sizing: border-box;
            margin: 0;
            display: flex;
            justify-content: center;
        }
        input, button {
            width: 30%;
            padding: 10px;
            font-size: 14px; /* Adjusts the font size */
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: rgba(67, 121, 138, 0.3);
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: rgba(29, 77, 92, 0.3);
        }

        #switch-button {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(173, 216, 230, 0.3);
            color: white;
            border: none;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            width: auto; /* Let the button size itself based on text */
            min-width: fit-content; /* Ensures it is only as wide as the text */
            white-space: nowrap; /* Prevents text from wrapping */
            transition: transform 0.7s ease-in-out, opacity 0.8s ease-in-out;
        }

        #switch-button:hover {
            background-color: darkgray;
        }

        #third-container{
            width:850px;
        }

        #third-container-background {
            width: 850px;
        }

        #progress-container {
            display: none;
            flex-direction: column;  /* Stack items vertically */
            align-items: center;  /* Center horizontally */
            justify-content: center;  /* Center vertically */
            width: 75%;  /* Ensure it spans the width */
            margin: 10px auto;  /* Center it with margin */
            text-align: center;  /* Center text */
        }
        #progress-bar {
            width: 100%;
            height: 25px;
        }
    </style>

<script>

    document.addEventListener("DOMContentLoaded", function() {
            var socket = io("/local-P1");  // Connect to correct namespace
            var progressBar = document.getElementById("progress-container");
            var page10Content = document.getElementById("page-10-content");
    
    
            socket.on("connect", function () {
                console.log("\tConnected to WebSocket for /local-P1!");
            });
    
            socket.on("disconnect", function () {
                console.log("\tDisconnected from WebSocket.");
            });
    
            socket.on("download_ready_P1", function (data) {
                console.log("\tModel is ready for download:", data.filename);
                
                // Auto-trigger the file download
                window.location.href = "/download-model-P1/" + encodeURIComponent(data.filename);
            });
    
            document.getElementById("upload-button").addEventListener("click", function () {
                let fileInput = document.getElementById("file");
                if (fileInput.files.length === 0) {
                    alert("Please choose a file before uploading.");
                    return;
                }
    
                let formData = new FormData();
                formData.append("file", fileInput.files[0]);
    
                fetch("/upload_P1", {
                    method: "POST",
                    body: formData
                })
                .then(response => response.text())
                .then(data => {
                    console.log("File uploaded successfully:", data);
                    page10Content.style.display = "flex"; // Show the container
                })
                .catch(error => console.error("Error:", error));
            });
    
            // Receive updated Plotly graph from Flask
            socket.on("plot_update", function (data) {
                console.log("Received new graph JSON.");
                var discgraphJSON = JSON.parse(data.disc_graph_json);  // Convert JSON back to Plotly figure
    
                Plotly.newPlot("disc-graph-container", discgraphJSON.data, discgraphJSON.layout);
            });
    
            document.getElementById("neural-net-form").addEventListener("submit", function (event) {
                event.preventDefault();  // Prevent default form submission
                
                // Get form values
                var lineBundle1 = Number(document.getElementById("line_bundle_1_nn").value);
                var lineBundle2 = Number(document.getElementById("line_bundle_2_nn").value);
                var filename = document.getElementById("filename").value.trim();
    
                // // Validate inputs: check if all fields are filled
                // if (lineBundle1 === "" || lineBundle2 === "" || filename === "") {
                //     alert("Please fill out all fields before submitting.");
                //     return;  // Stop execution if any field is empty
                // }
    
                // Append .pth extension to filename
                filename += ".pth";
    
                // Show progress bar
                progressBar.style.display = "block";
                document.getElementById("progress-bar").value = 0;
                document.getElementById("progress-text").innerText = "0%";
    
                // Emit form data via WebSocket
                socket.emit("train-model-P1", {
                    line_bundle_1: lineBundle1,
                    line_bundle_2: lineBundle2,
                    filename: filename
                });
            });
            socket.on("progress", function(data) {
    
                document.getElementById("progress-bar").value = data.progress;
                document.getElementById("progress-text").innerText = data.progress + "%";
    
                // Hide progress bar when task is complete
                if (data.progress >= 100) {
                    setTimeout(() => {
                        progressBar.style.display = "none";
                    }, 1000); // Optional: Hide after 1 second
                }
            });
        });
    
        </script>
</head>

<body>

    <button id="switch-button" onclick="returnHome()" style="font-size: 20px;">Home</button>

    <!-- Giving title of the first parallax -->
    <div class="parallax-1">
        <h2>Local $\mathbb{P}^1$</h2>
    </div>

    <!--Content of first parallax -->
    <div class="para-1">
        <p>
            The extra dimensions that arise in string theory would need to be <emph>compact</emph> of a very tiny scale in order to avoid experimental detection; by additionally assuming that 
            the theory admits a supersymmetry, we are in fact imposing a strong geometric condition on the compactified target space.
            <br/>
            <br/>
            In order to have an unbroken $\mathcal{N} = 1$ supersymmetry
            in 4 spacetime dimensions, there must exist a spinor which is covariantly constant (i.e. unchanged under parallel transport). On complex threefolds, this is equivalent
            to the claim that the holonomy of the underlying target space is $SU(3)$ — in other words, the manifold is Calabi-Yau.
        </p>
    </div>

    <!-- Giving title of the first parallax -->
    <div class="parallax-2">
        
    </div>

    <!--Content of first parallax -->
    <div class="para-2">
        <p>
            A gauge field configuration is defined by a connection $A$ on a holomorphic vector bundle $E \to M$ over some complex manifold $M$. 
            In this setting, vacuum solutions correspond to gauge field configurations which minimize the Yang-Mills action 
            $$
            S_{\operatorname{YM}} = \int_M \operatorname{Tr}(F_A \wedge \ast F_A)
            $$ 
            In supersymmetric Yang-Mills theory, one can show that a minimum-energy configuration is achieved only when the connection $A$ is a Hermite-Einstein connection.
            By a theorem of Donaldson-Ulhenbeck-Yau, this is mathematically equivalent to the bundle $E$ being $\mu_H$-stable with respect to some Kähler class $H$. 
        </p>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <p id="page-2-text-cont">
            In string theory, objects depending on some choice of Kähler class are often modified by world-sheet instanton corrections. In this context, the vacuaa are described as BPS vacua and correspond to
            Bridgeland-stable objects in the derived category of our compactified dimensions (i.e. the Calabi-Yau threefold). Unfortunately, only one example of a complex compact Kahler threefold that admits
            geometric Bridgeland stability conditions is known (c.f. <a href="https://link.springer.com/article/10.1007/s00222-019-00888-z">Li (2019)</a>). One can simplify the problem by considering models with only  
            two compactified dimensions, so that much of the physics revolves around the study of K3 surfaces (<emph>plotted below</emph>). Unfortunately, the derived categories of projective K3 surfaces are still quite tedious due to a huge class
            of "spherical objects" whose automorphisms make up an infinite collection of intertwining braid groups. 
        </p>
    </div>

    <!--This will be same as first parallax-->
    <div class="parallax-1">
        <div id="page-2-content">
            <div id="plot_k3" style="width: 40vw;"></div>
        </div>
    </div>

    <div class="para-2">
        <p>
            To make things even simpler, one can consider a 'localized' model that resembles the derived category of a K3 surface in an open neighborhood of a rational curve. 
             Specifically, one considers the total space of the canonical bundle of such a rational curve
             $$
            \pi : X = \operatorname{Tot}(\omega_{\mathbb{P}^1}) \to \mathbb{P}^1
             $$
             which is a quasi-projective Calabi-Yau, and looks at the category $\mathcal{D}_0 \subset D^\flat(X)$ consisting of complexes whose cohomology sheaves are supported on
             the rational curve. This category now encodes the data of only a single braid group configuration in its automorphism group, generated by <emph>two</emph> "spherical objects".
        </p>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <p>
            From the results of  Macrì and Bridgelandand, the authors of <a href="https://www.semanticscholar.org/paper/THE-STABILITY-MANIFOLDS-OF-P-AND-LOCAL-P-Bertram-Marcus/fe8856ea9b25f1af622fffac0a22c1bfbf325b23">Bertram, Marcus, Wang, (2013)</a> showed that the stability conditions on Local $\mathbb{P}^1$ simply arise as spherical twists of the standard stability conditions on $\mathbb{P}^1$
             These stability conditions are quite simple to understand — the central charge is always of the form $Z_w = -\operatorname{ch}_1 + w \cdot \operatorname{ch}_0$, so that an open region of the stability manifold is simply constructed from the complex paramter $w \in \mathbb{C}$. It may be difficult to tell from the above widget, but at integer points on the real line, the central charge 
             of some $\mathcal{O}_{\mathbb{P}^1}(n)$ vanishes — thus, there are actually punctures at each integer point.
        </p>
    </div>

    <!-- Giving title of the first parallax -->
    <div class="parallax-1">
        <div id="page-3-content">
            <canvas id="xy-plane" width="500" height="500"></canvas>
        </div>  
    </div>

    <div class="para-3">
        <p id="page-4-text">
            It turns out that crossing any interval $(k-1, k)$ on the real line (where $k$ is an integer) causes point-like objects to destabilize, thus leading to a new chamber identical
             to our original upper half-plane obtained by applying an automorphism known as the spherical twist $\operatorname{Tw}_{i_\ast \mathcal{O}_k} $. Since $D^\flat(\mathbb{P}^1)$ is a constructible category, another miracle that occurs in the case of
            local projective space is that any spherical twist / wall crossing through $(k-1, k)$ is the same as applying some composition of spherical twists around $0$ and $-1$. This initially paints the picture given to the left
        </p>
        <br/>
        <br/>
        <br/>

        <p id="page-4-text-cont">
            However, using the identification $$\operatorname{Tw}_{i_\ast \mathcal{O}(-n)} \circ \dots \circ \operatorname{Tw}_{i_\ast \mathcal{O}} \{ i_\ast \mathcal{O}, i_\ast \mathcal{O}(-1)[1] \} = \{ i_\ast \mathcal{O}(-n), i_\ast \mathcal{O}(-n-1)[1] \}$$ it turns out that many
             of the chambers above glue together, leading to a much more complicated decomposition than the one shown below.
        </p>
    </div>



    
    <!-- Giving title of the first parallax -->
    <div class="parallax-3">
        
    </div>

    <div class="para-4">
        <p>
        There are methods of resolving the identification of chambers (e.g. using the kernel of the tiling action to define an inverse such as $\operatorname{Tw}_1$ to $\operatorname{Tw}_{-1}$); however, it turns out that finding the mass of a standard line bundle in the other chambers is the same as finding the mass of a spherical twist in the original geometric chamber $\Theta_0$. Thus, the first purpose of this program is to plot the mass of spherical objects in the chamber $\Theta_0$.
        </p>
    </div>

        <!-- Giving title of the first parallax -->
        <div class="parallax-1">
            <div id="page-5-content">
                <!-- The First Container (Initially Off-Screen) -->
                <div class="container-background">
                    <div class="container" id="first-container">
                        <h2 style="color: #4d4d4d;">Single Spherical Twist Computation</h2>
                        <p>Compute the mass of $\operatorname{Tw}_{i_\ast \mathcal{O}(a)} i_\ast \mathcal{O}(b)$, where</p>
                        <br/>
                        <form id="sph-twist-form" action="/plot_sph_twist_P1" method="POST">
                            <label for="line_bundle_1">First line bundle degree $a$ (integer):</label>
                            <input type="number" id="line_bundle_1" name="line_bundle_1" placeholder="e.g. -1" required>
                            <br/>
                            <label for="line_bundle_2">Second line bundle degree $b$ (integer):</label>
                            <input type="number" id="line_bundle_2" name="line_bundle_2" placeholder="e.g. 1" required>
                            <br/>
                            <button type="submit">Get Prediction</button>
                        </form>
                    </div> 
                </div>
    
                <!-- <div class="container-background">
                    <div class="container" id="second-container">
                        <h2 style="color: #4d4d4d;">Single Spherical Twist Computation</h2>
                        <p>Compute the mass of $\operatorname{Tw}_{i_\ast \mathcal{O}(a)} \operatorname{Tw}_{i_\ast \mathcal{O}(b)} i_\ast \mathcal{O}(c)$, where</p>
                        <br/>
                        <form id="double-twist-form" action="/plot_double_sph_twist_P1" method="POST">
                            <label for="line_bundle_1">First line bundle degree $a$:</label>
                            <input type="number" id="line_bundle_1" name="line_bundle_1" placeholder="e.g. -1" required>
                            <br/>
                            <label for="line_bundle_2">Second line bundle degree $b$:</label>
                            <input type="number" id="line_bundle_2" name="line_bundle_2" placeholder="e.g. 1" required>
                            <br/>
                            <label for="line_bundle_3">Third line bundle degree $c$:</label>
                            <input type="number" id="line_bundle_3" name="line_bundle_3" placeholder="e.g. 2" required>
                            <br/>
                            <button type="submit">Get Prediction</button>
                        </form>
                    </div> 
                </div> -->
            </div>
        </div>

        <div class="para-5">
            <p id="page-6-text">
                After playing with a few of these computations, the user may note that there are some odd discontinuities in the plots where the mass does not behave the same that it does locally. These jumps should in fact <emph>not happen</emph> — a simple fact of the topology Bridgeland defined on stability manifolds in his seminal paper <a href="https://annals.math.princeton.edu/wp-content/uploads/annals-v166-n2-p01.pdf"><emph>Stability Conditions on Triangulated Catagories (2007)</emph></a> is that both the mass function $m_{\sigma}(-)$ and the min/max phase functions $\phi^{\pm}_{\sigma}(-)$ should be continuous as $\sigma$ is varied within the stability manifold. What is in fact happening is that the naïve methods used to compute the mass in this program's source files are not detecting that the factors in Harder-Narasimhan filtration of the spherical twist are coming from triangles more complicated than the "standard" defining triangle and its relatives.
            </p>
            <br/>
            <br/>
            <br/>
            <p>
                An interesting question in both mathematics and physics is to ask where the decay in the standard Harder-Narasimhan filtration is occuring for spherical twists. It is extremely difficult to mathematically pinpoint where the decay is occuring since we do not actually know what the 'new' Harder-Narasimhan filtration will be (and thus look at the phase functions of those respective objects) in the regions where the jump occurs — thus, the second purpose of this program is to attempt to train a neural network to predict where the discontinuities occur.
            </p>
            <br/>
            <br/>
            <br/>
            <p>
                Since we are looking at a discrete plot of the mass function, there are a few finite-element methods that can be used to predict the discontinuities in the mass function — for this program, we will primarily look for jumps in the discrete Laplacian:
                $$
                    \Delta m(x,y) \approx m(x + \Delta x, y) + m(x - \Delta x, y) + m(x, y + \Delta y) + m(x, y - \Delta y) - 4m(x,y)
                $$
            </p>
        </div>
    
        <div class="parallax-1">
            <div id="page-7-content">
                <div class="container-background" id="third-container-background">
                    <div class="container" id="third-container">
                        <h2 style="color: #4d4d4d;">Train Neural Network</h2>
                        <p>Train a neural network to predict the discontinuities of the spherical twist, and then download the model file</p>
                        <br/>
                        <form id="neural-net-form">
                            <label for="line_bundle_1_nn">First line bundle degree $a$:</label>
                            <input type="number" id="line_bundle_1_nn" name="line_bundle_1_nn" placeholder="e.g. -1" required>
                            <br/>
                            <label for="line_bundle_2_nn">Second line bundle degree $b$:</label>
                            <input type="number" id="line_bundle_2_nn" name="line_bundle_2_nn" placeholder="e.g. 1" required>
                            <br/>
                            <br/>
                            <label for="filename">Name of file to save model to:</label>
                            <input type="text" id="filename" name="filename" placeholder="spherical_twist_model" required><span>.pth</span>
                            <br/>
                            <div id="progress-container">
                                <progress id="progress-bar" value="0" max="100"></progress>
                                <p id="progress-text">0%</p>
                            </div>
                            <br/>
                            <button type="submit" id="download_button">Get model file</button>
                        </form>
                    </div> 
                </div>
            </div>
        </div>
    
    
        <div class="para-6">
            <p id="page-8-text">
                Programatically, we cannot simultaneously look at the entire $\alpha, \beta$-plane of possible inputs for the mass function; in other words, we are implicitly always looking at a bounded region on the $\alpha,\beta$-plane. Since the mass function is additionally smooth (<emph>in certain known examples</emph>), we can employ <a href="https://en.wikipedia.org/wiki/Swish_function">sigmoid linear unit</a> activation to prevent vanishing gradients in our neural network model — this ultimately allows the predicted discrete Laplacian graphs to appear much smoother than if we used a ReLU activation function.
            </p>
            <br/>
            <br/>
            <br/>
            <p>
                For demonstrational purposes, we will keep the neural network fairly small at only three layers with a maximum of 64 nodes. In addition, the network is only trained on a random set of roughly 20,000 datapoints from the same bounded region as our plots, and the training algorithm only backpropogates over 5,000 epochs.
            </p>
        </div>
    
        <div class="parallax-1">
            <div id="page-9-and-10-container">
                <div id="page-9-content">                
                    <div class="container-background" id="fourth-container-background">
                        <div class="container" id="fourth-container">
                            <h2 style="color: #4d4d4d;">Upload Neural Network Model</h2>
                            <p>Upload a .pth file containing a trained neural network of the discontinuity data</p>
                            <br/>
                            <form id="upload-form">
                                <label for="file">Choose a file:</label>
                                <input type="file" id="file" name="file" required>
                                <br><br>
                                <button type="button" id="upload-button">Upload File</button>
                            </form>
                        </div> 
                    </div>
                </div>
    
    
    
                <div id="page-10-content">
                    <div id="disc-graph-container"></div>  <!-- Graph will be inserted here -->
                </div>
            </div>
        </div>

</body>

<script>
    var k3_plot_json = {{ k3_plot_json | safe }};
    Plotly.newPlot('plot_k3', k3_plot_json.data, k3_plot_json.layout);

    document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('xy-plane');
            const ctx = canvas.getContext('2d');

            // Function to draw the x and y axes
            function drawAxes() {
                ctx.beginPath();
                ctx.moveTo(-canvas.width / 2, 0);
                ctx.lineTo(canvas.width / 2, 0);
                ctx.moveTo(0, -canvas.height / 2);
                ctx.lineTo(0, canvas.height / 2);
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Function to draw a circle at a given position
            function drawCircle(x, y, radius, color) {
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
            }

            // Initialize the canvas
            function initializeCanvas() {
                // Set up the coordinate system: move the origin to the center of the canvas
                ctx.translate(canvas.width / 2, canvas.height / 2);
                drawAxes();

                const step_size = canvas.height / 10;

                drawCircle(0,0, 0.1*step_size, 'gray');
                drawCircle(-1*step_size,0, 0.1*step_size, 'gray');
                drawCircle(1*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-2*step_size,0, 0.1*step_size, 'gray');
                drawCircle(2*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-4*step_size,0, 0.1*step_size, 'gray');
                drawCircle(4*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-5*step_size,0, 0.1*step_size, 'gray');
                drawCircle(5*step_size,0, 0.1*step_size, 'gray');

                

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-1*step_size, 0);
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.stroke();

                 // Draw the label
                 ctx.font = '16px Arial';
                ctx.fillStyle = 'blue';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('k(x)', -1.5*step_size, 0 );

            }

            // Function to clear the canvas and redraw the axes
            function clearCanvas() {
                // Clear the entire canvas
                ctx.clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);
                drawAxes();
            }

            // Function to draw a line from the origin to the clicked point
            function drawLineTo(x, y, label) {
                const step_size = canvas.height / 10;

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(x, y);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.stroke();

                 // Draw the label
                ctx.font = '16px Arial';
                ctx.fillStyle = 'red';
                ctx.textAlign = 'center';
                ctx.textBaseline = y > 0 ? 'bottom' : 'top';
                if (y > 0) {
                    ctx.fillText(label, x , y + 0.5*step_size);
                }
                else {
                    ctx.fillText(label, x , y - 0.5*step_size);
                }
                
            }

            

            // Event listener for mouse clicks
            canvas.addEventListener('click', (event) => {
                // Get the click position relative to the canvas
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left - canvas.width / 2;
                const y = event.clientY - rect.top - canvas.height / 2;

                const step_size = canvas.height / 10;

                // Clear the canvas, redraw the axes, and draw a line to the clicked point
                clearCanvas();

                
                drawLineTo(x, y, 'O');
                drawLineTo(x - step_size, y, 'O(-1)'); 
                drawLineTo(x + step_size, y, 'O(1)');
                drawLineTo(x-2*step_size, y, 'O(-2)');
                drawLineTo(x+2*step_size, y, 'O(2)');
                drawLineTo(x+3*step_size, y, 'O(3)');
                drawLineTo(x-3*step_size, y, 'O(-3)');
                drawLineTo(x-4*step_size, y, 'O(-4)');
                drawLineTo(x+4*step_size, y, 'O(4)');

                drawCircle(0,0, 0.1*step_size, 'gray');
                drawCircle(-1*step_size,0, 0.1*step_size, 'gray');
                drawCircle(1*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-2*step_size,0, 0.1*step_size, 'gray');
                drawCircle(2*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-4*step_size,0, 0.1*step_size, 'gray');
                drawCircle(4*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-5*step_size,0, 0.1*step_size, 'gray');
                drawCircle(5*step_size,0, 0.1*step_size, 'gray');

                

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-1*step_size, 0);
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.stroke();

                 // Draw the label
                 ctx.font = '16px Arial';
                ctx.fillStyle = 'blue';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('k(x)', -1.5*step_size, 0 );
            });

            // Initialize the canvas on page load
            initializeCanvas();
        });

        function returnHome() {
            window.location.href = "/"; // Redirect to Flask route
        }
</script>
  
</html>
