<!DOCTYPE html>
<html lang="en">
  
<head>
    <title>K3 Surfaces</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

    <!-- <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}"> -->

     <!-- Load MathJax v3 with AMS package -->
     <script>
        window.MathJax = {
            loader: {load: ['[tex]/amscd']},
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],  // Allow inline LaTeX
                displayMath: [['$$', '$$'], ['\\[', '\\]']],  // Allow display LaTeX
                packages: {'[+]': ['amscd']}
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>

    <script type="text/javascript" async 
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

    

    <style>

        /* Styling the body */
        * {
            margin: 0px;
            padding: 0px;
        }

        /* Styling the first parallax's 
        height, width and background color */
        .parallax-1 {
            width: 100%;
            height: 800px;
            background: linear-gradient(135deg, #1a1a1a, #333333, #4d4d4d);
            animation: gradientAnimation 10s infinite alternate ease-in-out;
            background-size: 300% 300%;
            background-position: 0% 50%;

            display: flex;
            justify-content: center;  /* Centers child horizontally */
            align-items: center;  /* Centers child vertically */
            flex-direction: column; /* Ensures children are stacked */
            text-align: center; /* Centers text */
        }

        /* Gradient Animation */
        @keyframes gradientAnimation {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        /* Styling the title of first parallax */
        .parallax-1 h2 {
            margin: auto;
            position: relative;
            /* left: 500x;
            top: 300px;
            width: 250px;
            height: 32px; */
            padding: 10px;
            color: white;
            text-align: center;

            /* Fade-in effect */
            opacity: 0; /* Initially hidden */
            animation: fadeIn 1s ease-in-out forwards;
            animation-delay: 1s; /* Delay appearance by 1 second */
        }

        @keyframes fadeIn {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }

        /* Styling the second parallax's 
        height, width and background color */
        .parallax-2 {
            width: 100%;
            height: 600px;
            background: url("{{ url_for('static', filename='images/CY3fold.gif') }}") no-repeat center center fixed;
            background-size: 100% 100%;
            background-attachment: fixed;
        }

        /* Styling the title of second parallax */
        .parallax-2 h2 {
            margin: auto;
            position: relative;
            left: 500x;
            top: 300px;
            width: 250px;
            height: 37px;
            padding: 10px;
            background-color: white;
            text-align: center;
            font-size: 30px;
            font-family: Verdana;
        }

        /* Styling the second parallax's 
        height, width and background color */
        .parallax-3 {
            width: 100%;
            height: 550px;
            background: url("{{ url_for('static', filename='images/naive_local_P1.png') }}") center fixed;
            background-size: 100% 100%;
            background-attachment: fixed;
        }

        /* Styling the content or paragraph */
        .para-1 {
            padding: 50px;
            background-color: black;
            color: white;
            font-size: 17px;
        }

        /* Styling the content or paragraph */
        .para-2 {
            padding: 25px;
            font-size: 17px;
            background-color: black;
            color: white;
        }

        /* Styling the content or paragraph */
        .para-3 {
            padding: 25px;
            font-size: 17px;
            background-color: black;
            color: white;
        }

        /* Styling the content or paragraph */
        .para-4 {
            padding: 25px;
            font-size: 17px;
            background-color: black;
            color: white;
        }


        #page-2-content {
            /* position: fixed; */
            display: flex; /* Keeps elements inside aligned */
            justify-content: center;  /* Centers horizontally */
            align-items: center;  /* Centers vertically */
            max-width: 50%; /* Prevents it from being too large */
            width: fit-content; /* Shrinks wrapper to fit the image */
            height: fit-content;
            position: relative; /* Ensures it remains within normal flow */
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        #page-3-content {
            /* position: fixed; */
            display: flex; /* Keeps elements inside aligned */
            justify-content: center;  /* Centers horizontally */
            align-items: center;  /* Centers vertically */
            max-width: 50%; /* Prevents it from being too large */
            width: fit-content; /* Shrinks wrapper to fit the image */
            height: fit-content;
            position: relative; /* Ensures it remains within normal flow */
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        /* Hidden image on page 5 */
        #page-5-content {
            display: flex; /* Keeps elements inside aligned */
            width: auto; /* Shrinks wrapper to fit the image */
            height: auto;
            justify-content: center;  /* Centers elements horizontally */
            align-items: center;  /* Aligns elements vertically */
            gap: 50px;  /* Adds 50px space between elements */
            
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        /* Initially position .container fully off-screen */
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 500px;
            max-width: 100%;
            box-sizing: border-box;
            margin: 0;
        }

        /* Initially position .container fully off-screen */
        .container-background {
            background: black;
            padding: 20px;
            width: fit-content; /* Shrinks wrapper to fit the image */
            height: fit-content;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 500px;
            box-sizing: border-box;
            margin: 0;
            display: flex;
            justify-content: center;
        }
        input, button {
            width: 30%;
            padding: 10px;
            font-size: 14px; /* Adjusts the font size */
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: #28a745;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #218838;
        }

        #switch-button {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: gray;
            color: white;
            border: none;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            width: auto; /* Let the button size itself based on text */
            min-width: fit-content; /* Ensures it is only as wide as the text */
            white-space: nowrap; /* Prevents text from wrapping */
            transition: transform 0.7s ease-in-out, opacity 0.8s ease-in-out;
        }

        #switch-button:hover {
            background-color: darkgray;
        }
    </style>
</head>

<body>

    <button id="switch-button" onclick="returnHome()" style="font-size: 20px;">Home</button>

    <!-- Giving title of the first parallax -->
    <div class="parallax-1">
        <h2>K3 Surfaces</h2>
    </div>

    <!--Content of first parallax -->
    <div class="para-1">
        <p>
            The extra dimensions that arise in string theory would need to be <emph>compact</emph> of a very tiny scale in order to avoid experimental detection; by additionally assuming that 
            the theory admits a supersymmetry, we are in fact imposing a strong geometric condition on the compactified target space.
            <br/>
            <br/>
            In order to have an unbroken $\mathcal{N} = 1$ supersymmetry
            in 4 spacetime dimensions, there must exist a spinor which is covariantly constant (i.e. unchanged under parallel transport). On complex threefolds, this is equivalent
            to the claim that the holonomy of the underlying target space is $SU(3)$ — in other words, the manifold is Calabi-Yau.
        </p>
    </div>

    <!-- Giving title of the first parallax -->
    <div class="parallax-2">
        
    </div>

    <!--Content of first parallax -->
    <div class="para-2">
        <p>
            A gauge field configuration is defined by a connection $A$ on a holomorphic vector bundle $E \to M$ over some complex manifold $M$. 
            In this setting, vacuum solutions correspond to gauge field configurations which minimize the Yang-Mills action 
            $$
            S_{\operatorname{YM}} = \int_M \operatorname{Tr}(F_A \wedge \ast F_A)
            $$ 
            In supersymmetric Yang-Mills theory, one can show that a minimum-energy configuration is achieved only when the connection $A$ is a Hermite-Einstein connection.
            By a theorem of Donaldson-Ulhenbeck-Yau, this is mathematically equivalent to the bundle $E$ being $\mu_H$-stable with respect to some Kähler class $H$. 
        </p>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        <p id="page-2-text-cont">
            In string theory, objects depending on some choice of Kähler class are often modified by world-sheet instanton corrections. In this context, the vacuaa are described as BPS vacua and correspond to
            Bridgeland-stable objects in the derived category of our compactified dimensions (i.e. the Calabi-Yau threefold). Unfortunately, only one example of a complex compact Kahler threefold that admits
            geometric Bridgeland stability conditions is known (c.f. <a href="https://link.springer.com/article/10.1007/s00222-019-00888-z">Li (2019)</a>). One can simplify the problem by considering models with only  
            two compactified dimensions, so that much of the physics revolves around the study of K3 surfaces (<emph>plotted below</emph>). 
        </p>
    </div>

    <!--This will be same as first parallax-->
    <div class="parallax-1">
        <div id="page-2-content">
            <div id="plot_k3" style="width: 40vw;"></div>
        </div>
    </div>

    <div class="para-2">
        The Bridgeland stability manifold of K3 surfaces was one of the first examples of stability conditions in higher dimensions, and was originally by Bridgeland himself in <a href="https://projecteuclid.org/journals/duke-mathematical-journal/volume-141/issue-2/Stability-conditions-on-K3-surfaces/10.1215/S0012-7094-08-14122-5.full"><em>Stability Conditions on K3 Surfaces</em>, (2008)</a>. Unlike the case of curves and simple resolutions of singularities, the stability conditions on a surface turn out to depend on the divisors (codimension 1 complex subvarieties) and their respective numerical classes, making even the geometric chamber much more difficult to compute. Similar to the case of our local projective spaces, it also turns out that there is an action of spherical twists on the stability manifold leading to a wall-and-chamber decomposition.
        <br/>
        <br/>
        <br/>
        In the simplest case that a K3 surface is Picard rank 1, every curve class is a multiple of the polarization $H$, so that there exist no rational curves $C \cong \mathbb{P}^1$ with $C^2 < 0$. In particular, every geometric stability condition is induced by $\sigma_{\alpha H, \beta H} = (Z_{\alpha, \beta}, \mathcal{P}_{\alpha, \beta})$ where
        $$
        Z_{\alpha, \beta} = \int_S \operatorname{exp}((\alpha + i \beta)H) \operatorname{ch}(-) \sqrt{\operatorname{td}(S)}
        $$
        However, there is a very subtle restriction on the values of $\alpha$ and $\beta$ that make the stability condition $\sigma_{\alpha H, \beta H}$ a Bridgeland stability condition; in particular, there are punctures in the $(\alpha, \beta)$-plane corresponding to where spherical objects become massless, and the values of $\alpha$ and $\beta$ should not lie below these punctured. This is pictured below for a degree $2$ double cover of $\mathbb{P}^2$ branched along a sextic (e.g. locally of the form $z^2 = f_6(x,y,w)$ in the weighted projective space $\mathbb{P}(1,1,1,3)$).
    </div>

    <!-- Giving title of the first parallax -->
    <div class="parallax-1">
        <div id="page-3-content">
            <div id="plot_alpha_beta" style="width: 40vw;"></div>
        </div>  
    </div>

    <div class="para-3">
        <p id="page-4-text">
            Crossing any of these walls underneath a puncture corresponding to some spherical object $S$ leads to a completely new geometric chamber identical to the first, with the same sets of walls and holes. Unlike the case of our local projective spaces, there is <emph>no identification between the different chambers</emph>. This means that there is a true tree-like structure of chambers that branch off from the original geometric chamber; to make matters more complicated, there are infinitely many branches going in "upwards" and "downwards" directions and each new chamber at the end of the branch has infinitely many children. 
        </p>
        <br/>
        <br/>
        <br/>

        <p id="page-4-text-cont">
            The only upshot of computing masses is that the $\operatorname{Ext}$-algebras (corresponding to the open string spectra) on K3 surfaces of Picard rank 1 are much easier to compute. Thus, we are able to attempt to compute masses of "farther neighboring chambers", though we will never actually be able to even compute the masses for all adjacent chambers simultaneously. Thus, the first purpose of this program for K3 surfaces is to plot the mass of spherical objects in chambers that are either adjacent to the geometric chamber or distance 2 away from it.
        </p>
    </div>



    


        <!-- Giving title of the first parallax -->
        <div class="parallax-1">
            <div id="page-5-content">
                <!-- The First Container (Initially Off-Screen) -->
                <div class="container-background">
                    <div class="container" id="first-container">
                        <h2 style="color: #4d4d4d;">Single Spherical Twist Computation</h2>
                        <p>Compute the mass of $\operatorname{Tw}_{ \mathcal{O}(a)}  \mathcal{O}(b)$, where</p>
                        <br/>
                        <form id="sph-twist-form" action="/plot_sing_sph_twist_K3" method="POST">
                            <label for="line_bundle_1">First line bundle degree $a$ (integer):</label>
                            <input type="number" id="line_bundle_1" name="line_bundle_1" placeholder="e.g. -1" required>
                            <br/>
                            <label for="line_bundle_2">Second line bundle degree $b$ (integer):</label>
                            <input type="number" id="line_bundle_2" name="line_bundle_2" placeholder="e.g. 1" required>
                            <br/>
                            <button type="submit">Get Prediction</button>
                        </form>
                    </div> 
                </div>
    
                <div class="container-background">
                    <div class="container" id="second-container">
                        <h2 style="color: #4d4d4d;">Double Spherical Twist Computation</h2>
                        <p>Compute the mass of $\operatorname{Tw}_{\mathcal{O}(a)} \operatorname{Tw}_{\mathcal{O}(b)} \mathcal{O}(c)$, where</p>
                        <br/>
                        <form id="double-twist-form" action="/plot_double_sph_twist_K3" method="POST">
                            <label for="line_bundle_1">First line bundle degree $a$:</label>
                            <input type="number" id="line_bundle_1" name="line_bundle_1" placeholder="e.g. -1" required>
                            <br/>
                            <label for="line_bundle_2">Second line bundle degree $b$:</label>
                            <input type="number" id="line_bundle_2" name="line_bundle_2" placeholder="e.g. 1" required>
                            <br/>
                            <label for="line_bundle_3">Third line bundle degree $c$:</label>
                            <input type="number" id="line_bundle_3" name="line_bundle_3" placeholder="e.g. 2" required>
                            <br/>
                            <button type="submit">Get Prediction</button>
                        </form>
                    </div> 
                </div>
            </div>
        </div>

</body>

<script>
    var k3_plot_json = {{ k3_plot_json | safe }};
    var  K3_alpha_beta_json = {{ K3_alpha_beta_json | safe }};
    Plotly.newPlot('plot_k3', k3_plot_json.data, k3_plot_json.layout);
    Plotly.newPlot('plot_alpha_beta', K3_alpha_beta_json.data, K3_alpha_beta_json.layout);

    document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('xy-plane');
            const ctx = canvas.getContext('2d');

            // Function to draw the x and y axes
            function drawAxes() {
                ctx.beginPath();
                ctx.moveTo(-canvas.width / 2, 0);
                ctx.lineTo(canvas.width / 2, 0);
                ctx.moveTo(0, -canvas.height / 2);
                ctx.lineTo(0, canvas.height / 2);
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Function to draw a circle at a given position
            function drawCircle(x, y, radius, color) {
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
            }

            // Initialize the canvas
            function initializeCanvas() {
                // Set up the coordinate system: move the origin to the center of the canvas
                ctx.translate(canvas.width / 2, canvas.height / 2);
                drawAxes();

                const step_size = canvas.height / 10;

                drawCircle(0,0, 0.1*step_size, 'gray');
                drawCircle(-1*step_size,0, 0.1*step_size, 'gray');
                drawCircle(1*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-2*step_size,0, 0.1*step_size, 'gray');
                drawCircle(2*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-4*step_size,0, 0.1*step_size, 'gray');
                drawCircle(4*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-5*step_size,0, 0.1*step_size, 'gray');
                drawCircle(5*step_size,0, 0.1*step_size, 'gray');

                

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-1*step_size, 0);
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.stroke();

                 // Draw the label
                 ctx.font = '16px Arial';
                ctx.fillStyle = 'blue';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('k(x)', -1.5*step_size, 0 );

            }

            // Function to clear the canvas and redraw the axes
            function clearCanvas() {
                // Clear the entire canvas
                ctx.clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);
                drawAxes();
            }

            // Function to draw a line from the origin to the clicked point
            function drawLineTo(x, y, label) {
                const step_size = canvas.height / 10;

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(x, y);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.stroke();

                 // Draw the label
                ctx.font = '16px Arial';
                ctx.fillStyle = 'red';
                ctx.textAlign = 'center';
                ctx.textBaseline = y > 0 ? 'bottom' : 'top';
                if (y > 0) {
                    ctx.fillText(label, x , y + 0.5*step_size);
                }
                else {
                    ctx.fillText(label, x , y - 0.5*step_size);
                }
                
            }

            

            // Event listener for mouse clicks
            canvas.addEventListener('click', (event) => {
                // Get the click position relative to the canvas
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left - canvas.width / 2;
                const y = event.clientY - rect.top - canvas.height / 2;

                const step_size = canvas.height / 10;

                // Clear the canvas, redraw the axes, and draw a line to the clicked point
                clearCanvas();

                
                drawLineTo(x, y, 'O');
                drawLineTo(x - step_size, y, 'O(-1)'); 
                drawLineTo(x + step_size, y, 'O(1)');
                drawLineTo(x-2*step_size, y, 'O(-2)');
                drawLineTo(x+2*step_size, y, 'O(2)');
                drawLineTo(x+3*step_size, y, 'O(3)');
                drawLineTo(x-3*step_size, y, 'O(-3)');
                drawLineTo(x-4*step_size, y, 'O(-4)');
                drawLineTo(x+4*step_size, y, 'O(4)');

                drawCircle(0,0, 0.1*step_size, 'gray');
                drawCircle(-1*step_size,0, 0.1*step_size, 'gray');
                drawCircle(1*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-2*step_size,0, 0.1*step_size, 'gray');
                drawCircle(2*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(3*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-4*step_size,0, 0.1*step_size, 'gray');
                drawCircle(4*step_size,0, 0.1*step_size, 'gray');
                drawCircle(-5*step_size,0, 0.1*step_size, 'gray');
                drawCircle(5*step_size,0, 0.1*step_size, 'gray');

                

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-1*step_size, 0);
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.stroke();

                 // Draw the label
                 ctx.font = '16px Arial';
                ctx.fillStyle = 'blue';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('k(x)', -1.5*step_size, 0 );
            });

            // Initialize the canvas on page load
            initializeCanvas();
        });

        function returnHome() {
            window.location.href = "/"; // Redirect to Flask route
        }
</script>
  
</html>
