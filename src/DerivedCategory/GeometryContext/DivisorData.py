from sympy import Symbol, Basic, expand, S, prod, Expr
from itertools import permutations, product
from collections import defaultdict
from collections.abc import Mapping

from typing import List



class DivisorData:
    r"""!
    A class which represents the matrix for an intersection form on the cohomology ring. Specifically, this class only
    tracks the values obtained when intersecting the top-dimensional number of divisors. For example, if this class is meant
    to model the intersection form on a smooth projective threefold and the Picard group is generated by [X, Y, Z], then the intersection form should only keep tract of the intersection values of X.X.X or X.Y.Z, etc. 

    The intersection form is a symmetric bilinear form on the cohomology ring, which means that one only needs to provide the information of the intersection numbers on a single permutation of the generators. The intersection form is then symmetrized by summing over all permutations of the generators.

    The intersection form is represented as a dictionary, where the keys are tuples of basis elements and the values are the
    intersection numbers. For example, if the intersection form is given by the dictionary { (X, Y): 1, (Y, Z): 2 }, then the
    intersection number of X and Y is 1, and the intersection number of Y and Z is 2. The intersection form is symmetric, so
    the intersection number of Y and X is also 1. The intersection number of X and Z is not defined, so it is not included in the
    dictionary.
    """

    def __init__(self, basis : List[Symbol], top_intersection_form : Mapping):
        r"""!
        Initialize the intersection form with a specified basis consisting of SymPy symbols for divisor classes, the dimension of the ambient variety, and a dictionary / Mapping of intersection numbers. As the intersection form is symmetric, the user only needs to provide the intersection numbers for one permutation of the generators. The intersection form is then symmetrized by summing over all permutations of the generators.

        \param basis list A list of SymPy symbols representing the basis elements of the cohomology ring.
        \param dimension int The dimension of the ambient variety.
        \param tensor_data Mapping A dictionary / Mapping of intersection numbers, where the keys are tuples of basis elements and the values are the intersection numbers. The keys must be tuples of the same length as the dimension and the values must be numeric.

        \throws TypeError If the basis is not a list, if the basis elements are not SymPy symbols, if the dimension is not an integer, if the tensor data is not a dictionary, if the tensor keys are not tuples, or if the tensor values are not numeric.
        \throws ValueError If the dimension is negative, if the tensor keys do not have the same length as the dimension, or if the tensor values are not numeric.
        """

        if not isinstance(basis, list):
            raise TypeError("Basis must be a list")
        if not all(isinstance(b, Symbol) for b in basis):
            raise TypeError("All basis elements must be SymPy symbols")
        

        # Verify the tensor_data

        if not isinstance(top_intersection_form, Mapping):
            raise TypeError("Tensor data must be a dictionary")
        if not all(isinstance(k, tuple) for k in top_intersection_form.keys()):
            raise TypeError("Tensor keys must be tuples of SymPy symbols")
        if not all( all(isinstance(entry, Symbol) for entry in k) for k in top_intersection_form.keys()):
            raise TypeError("Tensor keys must be tuples of SymPy symbols")
        
        # Grab the number of entries in the first key
        temp_len = len(next(iter(top_intersection_form)))

        if not all(len(k) == temp_len for k in top_intersection_form.keys()):
            raise ValueError("Tensor keys must have the same length")
        if not all(isinstance(v, (int, float, S)) for v in top_intersection_form.values()):
            raise TypeError("Tensor values must be numeric")
        
        self.variety_dimension = temp_len ## The dimension of the ambient variety

        self.basis = basis ## The list of valid SymPy symbols that the intersection form is defined for

        self.top_intersection_form = defaultdict(lambda: S(0)) ## The dictionary or mapping object used to store the intersection numbers. The default value is 0, which is the identity element for addition.

        # Symmetrize input
        for key, val in top_intersection_form.items():
            for perm in set(permutations(key)):
                self.top_intersection_form[perm] += S(val) 


    def _expand_expr(self, expr):
        r"""!
        Helper function which takes a SymPy expression representing a polynomial in some formal variables over the basis, and breaks the expression into a list of tuples, where each tuple contains the coefficient and a list of the basis elements in the monomial. For example, if the input expression is 2*H**3 + 3*D**2*H, then the output will be [(2, [H, H, H]), (3, [D, D, H])]. The function also checks that all symbols in the expression are in the basis.

        \param expr SymPy expression A SymPy expression representing a polynomial in some formal variables over the basis. The expression must be a linear combination of the basis elements.

        \throws ValueError If the expression contains symbols not in the basis, or if the expression contains powers of symbols that are not integers or are negative.

        \throws TypeError If the expression is not a SymPy expression.

        \return list A list of tuples, where each tuple contains the coefficient and a list of the basis elements in the monomial. For example, if the input expression is 2*H**3 + 3*D**2*H, then the output will be [(2, [H, H, H]), (3, [D, D, H])].
        """

        if not isinstance(expr, (int, float, Symbol, Basic)):
            raise TypeError("Expression must be a SymPy expression")

        # Verify that the expression is a linear combination of the basis elements
        used_symbols = expr.free_symbols
        invalid = used_symbols - set(self.basis)
        if invalid:
            raise ValueError(f"Expression uses symbols not in the basis: {', '.join(str(s) for s in invalid)}")
    

        expr = expand(expr)
        terms = []
        # Split the expression into its terms (separated by + or -)
        for term in expr.as_ordered_terms():
            # Further split into coefficient and monomial, e.g. 3*H**2*D -> (3, H**2*D)
            coeff, monomial = term.as_coeff_Mul()

            # Break monomial into base ** exp factors
            factors = []
            for factor in monomial.as_ordered_factors():
                if factor.is_Pow:
                    base, exp = factor.args
                    if not exp.is_Integer or exp < 0:
                        raise ValueError(f"Unsupported power: {factor}")
                    # represent H**3 as H*H*H and D**2 as D*D
                    factors.extend([base] * int(exp))
                else:
                    # Separates out individual factors --- e.g. H*D into H and D
                    factors.append(factor)

            terms.append((coeff, factors))
        return terms
    


    def evaluate(self, *exprs) -> Expr:
        r"""!
        Function which computes the intersection number of a given SymPy expression using the stored intersection form / dictionary provided at initialization. The function takes a variable number of SymPy expressions as input, and computes the intersection number obtained by intersecting the monomials in the expressions. The function returns the intersection number as a SymPy expression.

        \param exprs list A variable number of SymPy expressions representing polynomials in some formal variables over the basis. The expressions must be linear combinations of the basis elements.

        \throws ValueError If the degree of some product of terms in the input is not equal to the dimension of the intersection form.

        \return SymPy expression A SymPy expression representing the intersection number obtained by intersecting the monomials in the expressions. The expression is a linear combination of the basis elements.
        """


        expr_terms = [self._expand_expr(e) for e in exprs]
        total = S(0)


        for combo in product(*expr_terms):
            coeffs = [c for c, _ in combo]
            mon_lists = [m for _, m in combo]
            flat_mons = [m for sublist in mon_lists for m in sublist]

            if len(flat_mons) != self.variety_dimension:
                raise ValueError(f"The degree of some product of terms in the input is {len(flat_mons)}, but the intersection form is only defined for degree {self.variety_dimension}.")

            # If the tuple of monomials is not in the dictionary, return 0
            val = self.top_intersection_form.get(tuple(flat_mons), 0)
            total += S(val) * prod(coeffs)

        return total
    

    def __eq__(self, other):
        if not isinstance(other, DivisorData):
            return False
        return self.basis == other.basis and self.top_intersection_form == other.top_intersection_form
    

    def is_linear_combination_of_basis(self, expr: Expr) -> bool:
        """
        Checks if expr is a linear combination of the basis.
        That is, expr = sum_i (a_i * b_i), where b_i in basis_symbols and a_i ∈ ℚ or ℝ.
        No constants, no nonlinear terms, and no unknown symbols allowed.
        """
        expr = expr.expand()
        basis_set = set(self.basis)

        terms = expr.as_ordered_terms()

        for term in terms:
            if term.is_Atom:
                # A bare symbol or number is not allowed unless it's in basis
                if term in basis_set:
                    continue
                return False

            coeff, rest = term.as_coeff_Mul()

            if rest.is_Atom:
                # Must be a single basis symbol
                if rest not in basis_set:
                    return False
            else:
                # If rest is a product or something more complex: invalid
                # E.g. H*C, H**2, etc.
                symbols_in_term = rest.free_symbols
                if not symbols_in_term <= basis_set:
                    return False
                return False

        return True
    

    def is_effective(self, divisor: Expr) -> bool:
        """
        Check whether a given divisor is effective in this basis.
        That is, all coefficients of the basis divisors are non-negative,
        and the divisor is a linear combination of the basis elements only.

        Raises:
            ValueError: if divisor contains terms outside the basis
        """

        # Check that all symbols in the divisor are part of the basis
        if not self.is_linear_combination_of_basis(divisor):
            raise ValueError(f"Divisor {divisor} is not a linear combination of the basis elements.")

        # Check that all coefficients of basis elements are ≥ 0
        return all(divisor.coeff(b) >= 0 for b in self.basis)