<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DerivedCatagoryMass: src.ChainComplex.ChainComplex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DerivedCatagoryMass
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsrc_1_1_chain_complex_1_1_chain_complex.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classsrc_1_1_chain_complex_1_1_chain_complex-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">src.ChainComplex.ChainComplex Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>For any abelian category, a chain complex is a sequence of objects and morphisms between them such that the composition of any two consecutive morphisms is the zero morphism.  
 <a href="#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for src.ChainComplex.ChainComplex:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsrc_1_1_chain_complex_1_1_chain_complex.png" usemap="#src.ChainComplex.ChainComplex_map" alt=""/>
  <map id="src.ChainComplex.ChainComplex_map" name="src.ChainComplex.ChainComplex_map">
<area href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html" title="This class acts as a general parent class for objects in the derived category of coherent sheaves." alt="src.DerivedCategoryObject.DerivedCategoryObject" shape="rect" coords="0,0,306,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a72ab48cf534d48b0f2cc7e55c09b6a54" id="r_a72ab48cf534d48b0f2cc7e55c09b6a54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72ab48cf534d48b0f2cc7e55c09b6a54">__init__</a> (self, <a class="el" href="#a864ac31fa0d9fe9a4c50f803cc6023b8">sheaf_vector</a>, <a class="el" href="#ad30a876c85094c7347ea6180fb058171">shift_vector</a>, <a class="el" href="#a6373f5a40572d1c1b76bfb3e0b0bf40c">dimension_vector</a>=None)</td></tr>
<tr class="memdesc:a72ab48cf534d48b0f2cc7e55c09b6a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an instance of <a class="el" href="classsrc_1_1_chain_complex_1_1_chain_complex.html" title="For any abelian category, a chain complex is a sequence of objects and morphisms between them such th...">ChainComplex</a> with the specified sheaf vector, shift vector, and potentially a dimension vector.  <br /></td></tr>
<tr class="separator:a72ab48cf534d48b0f2cc7e55c09b6a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfc291368151be74b669b4f2edd9c79" id="r_adbfc291368151be74b669b4f2edd9c79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbfc291368151be74b669b4f2edd9c79">__str__</a> (self)</td></tr>
<tr class="memdesc:adbfc291368151be74b669b4f2edd9c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">String representation of the chain complex.  <br /></td></tr>
<tr class="separator:adbfc291368151be74b669b4f2edd9c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e811d0d0ed0e471f7666c51e7a483e" id="r_a85e811d0d0ed0e471f7666c51e7a483e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85e811d0d0ed0e471f7666c51e7a483e">__len__</a> (self)</td></tr>
<tr class="memdesc:a85e811d0d0ed0e471f7666c51e7a483e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of the chain complex is the number of sheaves in the complex.  <br /></td></tr>
<tr class="separator:a85e811d0d0ed0e471f7666c51e7a483e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7b95df49db36f52234bd8809b6a843" id="r_a0d7b95df49db36f52234bd8809b6a843"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d7b95df49db36f52234bd8809b6a843">chernCharacter</a> (self)</td></tr>
<tr class="memdesc:a0d7b95df49db36f52234bd8809b6a843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to compute the Chern Character of the chain complex.  <br /></td></tr>
<tr class="separator:a0d7b95df49db36f52234bd8809b6a843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70373ec03d47a5d6dd8e8694186ae138" id="r_a70373ec03d47a5d6dd8e8694186ae138"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70373ec03d47a5d6dd8e8694186ae138">central_charge</a> (self, *args)</td></tr>
<tr class="memdesc:a70373ec03d47a5d6dd8e8694186ae138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the central charge of the chain complex.  <br /></td></tr>
<tr class="separator:a70373ec03d47a5d6dd8e8694186ae138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ddcc7b614880bd8889c944f76237ee" id="r_a06ddcc7b614880bd8889c944f76237ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06ddcc7b614880bd8889c944f76237ee">shift</a> (self, shift)</td></tr>
<tr class="memdesc:a06ddcc7b614880bd8889c944f76237ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to shift the chain complex by a given homological shift.  <br /></td></tr>
<tr class="separator:a06ddcc7b614880bd8889c944f76237ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb46ca115fc7fef97f7f4676a74cfe8" id="r_a6fb46ca115fc7fef97f7f4676a74cfe8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fb46ca115fc7fef97f7f4676a74cfe8">isShiftOfSheaf</a> (self)</td></tr>
<tr class="memdesc:a6fb46ca115fc7fef97f7f4676a74cfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple helper function which checks if the complex is a shift of a single sheaf.  <br /></td></tr>
<tr class="separator:a6fb46ca115fc7fef97f7f4676a74cfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36340635bb9a289121eb96778a5b4da3" id="r_a36340635bb9a289121eb96778a5b4da3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36340635bb9a289121eb96778a5b4da3">get_smallest_phase</a> (self, *args)</td></tr>
<tr class="memdesc:a36340635bb9a289121eb96778a5b4da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to compute the smallest phase of the chain complex.  <br /></td></tr>
<tr class="separator:a36340635bb9a289121eb96778a5b4da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc104a639fb1e10753ad4552ba9b1792" id="r_adc104a639fb1e10753ad4552ba9b1792"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc104a639fb1e10753ad4552ba9b1792">get_largest_phase</a> (self, *args)</td></tr>
<tr class="memdesc:adc104a639fb1e10753ad4552ba9b1792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to compute the largest phase of the chain complex.  <br /></td></tr>
<tr class="separator:adc104a639fb1e10753ad4552ba9b1792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ec73042f19e9896f67b2a1724928d7" id="r_ab0ec73042f19e9896f67b2a1724928d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0ec73042f19e9896f67b2a1724928d7">is_semistable</a> (self, *args)</td></tr>
<tr class="memdesc:ab0ec73042f19e9896f67b2a1724928d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to compute whether the chain complex is semistable.  <br /></td></tr>
<tr class="separator:ab0ec73042f19e9896f67b2a1724928d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsrc_1_1_derived_category_object_1_1_derived_category_object"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsrc_1_1_derived_category_object_1_1_derived_category_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html">src.DerivedCategoryObject.DerivedCategoryObject</a></td></tr>
<tr class="memitem:a5b917d2624a9a499671f11e809397d71 inherit pub_methods_classsrc_1_1_derived_category_object_1_1_derived_category_object" id="r_a5b917d2624a9a499671f11e809397d71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html#a5b917d2624a9a499671f11e809397d71">__init__</a> (self, <a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html#a244258a02691a74e0787cf277c5935c5">catagory</a>, <a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html#ab7174b1273139ac7d0c2bc6f7c4d1789">string</a>=&quot;0&quot;, <a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html#a111bf62635e3a204488ca33689d296e6">chern_character</a>=None)</td></tr>
<tr class="memdesc:a5b917d2624a9a499671f11e809397d71 inherit pub_methods_classsrc_1_1_derived_category_object_1_1_derived_category_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an instance of the <a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html" title="This class acts as a general parent class for objects in the derived category of coherent sheaves.">DerivedCategoryObject</a> with the specified catagory, string representation, and Chern Character.  <br /></td></tr>
<tr class="separator:a5b917d2624a9a499671f11e809397d71 inherit pub_methods_classsrc_1_1_derived_category_object_1_1_derived_category_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac086dabebbde64c028446348301011f2 inherit pub_methods_classsrc_1_1_derived_category_object_1_1_derived_category_object" id="r_ac086dabebbde64c028446348301011f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html#ac086dabebbde64c028446348301011f2">__str__</a> (self)</td></tr>
<tr class="memdesc:ac086dabebbde64c028446348301011f2 inherit pub_methods_classsrc_1_1_derived_category_object_1_1_derived_category_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">String representation of the derived category object.  <br /></td></tr>
<tr class="separator:ac086dabebbde64c028446348301011f2 inherit pub_methods_classsrc_1_1_derived_category_object_1_1_derived_category_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffd63e97c717dd171b7d1c7ef26e16d inherit pub_methods_classsrc_1_1_derived_category_object_1_1_derived_category_object" id="r_a9ffd63e97c717dd171b7d1c7ef26e16d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html#a9ffd63e97c717dd171b7d1c7ef26e16d">update_string_by_shift</a> (self, my_str, n)</td></tr>
<tr class="memdesc:a9ffd63e97c717dd171b7d1c7ef26e16d inherit pub_methods_classsrc_1_1_derived_category_object_1_1_derived_category_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static helper function to update the possible string representations of the abstract <a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html" title="This class acts as a general parent class for objects in the derived category of coherent sheaves.">DerivedCategoryObject</a> by a homological shift.  <br /></td></tr>
<tr class="separator:a9ffd63e97c717dd171b7d1c7ef26e16d inherit pub_methods_classsrc_1_1_derived_category_object_1_1_derived_category_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a864ac31fa0d9fe9a4c50f803cc6023b8" id="r_a864ac31fa0d9fe9a4c50f803cc6023b8"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a864ac31fa0d9fe9a4c50f803cc6023b8">sheaf_vector</a> = sheaf_vector</td></tr>
<tr class="memdesc:a864ac31fa0d9fe9a4c50f803cc6023b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of coherent sheaves in the complex, so that the chain complex can operate similar to a DenseVector.  <br /></td></tr>
<tr class="separator:a864ac31fa0d9fe9a4c50f803cc6023b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6373f5a40572d1c1b76bfb3e0b0bf40c" id="r_a6373f5a40572d1c1b76bfb3e0b0bf40c"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6373f5a40572d1c1b76bfb3e0b0bf40c">dimension_vector</a> = dimension_vector</td></tr>
<tr class="memdesc:a6373f5a40572d1c1b76bfb3e0b0bf40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of the number of direct sums of each coherent sheaf in the complex.  <br /></td></tr>
<tr class="separator:a6373f5a40572d1c1b76bfb3e0b0bf40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30a876c85094c7347ea6180fb058171" id="r_ad30a876c85094c7347ea6180fb058171"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad30a876c85094c7347ea6180fb058171">shift_vector</a> = shift_vector</td></tr>
<tr class="memdesc:ad30a876c85094c7347ea6180fb058171"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of homological shifts in the complex.  <br /></td></tr>
<tr class="separator:ad30a876c85094c7347ea6180fb058171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classsrc_1_1_derived_category_object_1_1_derived_category_object"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_attribs_classsrc_1_1_derived_category_object_1_1_derived_category_object')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html">src.DerivedCategoryObject.DerivedCategoryObject</a></td></tr>
<tr class="memitem:a244258a02691a74e0787cf277c5935c5 inherit pub_attribs_classsrc_1_1_derived_category_object_1_1_derived_category_object" id="r_a244258a02691a74e0787cf277c5935c5"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html#a244258a02691a74e0787cf277c5935c5">catagory</a> = catagory</td></tr>
<tr class="memdesc:a244258a02691a74e0787cf277c5935c5 inherit pub_attribs_classsrc_1_1_derived_category_object_1_1_derived_category_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">The catagory of the derived category object.  <br /></td></tr>
<tr class="separator:a244258a02691a74e0787cf277c5935c5 inherit pub_attribs_classsrc_1_1_derived_category_object_1_1_derived_category_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111bf62635e3a204488ca33689d296e6 inherit pub_attribs_classsrc_1_1_derived_category_object_1_1_derived_category_object" id="r_a111bf62635e3a204488ca33689d296e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html#a111bf62635e3a204488ca33689d296e6">chern_character</a> = chern_character</td></tr>
<tr class="memdesc:a111bf62635e3a204488ca33689d296e6 inherit pub_attribs_classsrc_1_1_derived_category_object_1_1_derived_category_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Chern Character of the derived category object.  <br /></td></tr>
<tr class="separator:a111bf62635e3a204488ca33689d296e6 inherit pub_attribs_classsrc_1_1_derived_category_object_1_1_derived_category_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7174b1273139ac7d0c2bc6f7c4d1789 inherit pub_attribs_classsrc_1_1_derived_category_object_1_1_derived_category_object" id="r_ab7174b1273139ac7d0c2bc6f7c4d1789"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html#ab7174b1273139ac7d0c2bc6f7c4d1789">string</a> = string</td></tr>
<tr class="memdesc:ab7174b1273139ac7d0c2bc6f7c4d1789 inherit pub_attribs_classsrc_1_1_derived_category_object_1_1_derived_category_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string representation / label of the derived category object.  <br /></td></tr>
<tr class="separator:ab7174b1273139ac7d0c2bc6f7c4d1789 inherit pub_attribs_classsrc_1_1_derived_category_object_1_1_derived_category_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af05e1ce45f86ad32474b98d8a17f7a73" id="r_af05e1ce45f86ad32474b98d8a17f7a73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af05e1ce45f86ad32474b98d8a17f7a73">_remove_zeros_from_dimension_vector</a> (self)</td></tr>
<tr class="memdesc:af05e1ce45f86ad32474b98d8a17f7a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function which iterates through the dimension vector, and if a certain Coherent sheaf is only included 0 times, we may effectively erase it.  <br /></td></tr>
<tr class="separator:af05e1ce45f86ad32474b98d8a17f7a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0baf08c80270b5ccdf997788aeb1070" id="r_aa0baf08c80270b5ccdf997788aeb1070"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0baf08c80270b5ccdf997788aeb1070">_combine_repeats</a> (self)</td></tr>
<tr class="memdesc:aa0baf08c80270b5ccdf997788aeb1070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to combine repeated sheaves in the complex.  <br /></td></tr>
<tr class="separator:aa0baf08c80270b5ccdf997788aeb1070"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>For any abelian category, a chain complex is a sequence of objects and morphisms between them such that the composition of any two consecutive morphisms is the zero morphism. </p>
<p>In the derived category of coherent sheaves on P^2, we can represent a chain complex as a sequence of coherent sheaves with a shift. For instance, a general complex will be of the form </p><pre class="fragment">         i=-n       i=-n+1      i=-n+2    ...
0 ------&gt; E1 -------&gt; E2 --------&gt; E3 ---&gt; ...
</pre><p>(A priori, there is no reason the complexes cant also descend infinitely in the other direction). For the purposes of this project, only finite complexes will be considered. Such a complex can be stored in a similar way to a DenseVector object &mdash; namely, since the majority of entries in the complex will be zero, we can store the complex as a list of coherent sheaves and a shift vector. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a72ab48cf534d48b0f2cc7e55c09b6a54" name="a72ab48cf534d48b0f2cc7e55c09b6a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ab48cf534d48b0f2cc7e55c09b6a54">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex.__init__ </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sheaf_vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>shift_vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dimension_vector</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an instance of <a class="el" href="classsrc_1_1_chain_complex_1_1_chain_complex.html" title="For any abelian category, a chain complex is a sequence of objects and morphisms between them such th...">ChainComplex</a> with the specified sheaf vector, shift vector, and potentially a dimension vector. </p>
<p>If a dimension vector is not provided, it must consist of non-negative integer values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>sheaf_vector A list of coherent sheaves in the complex </td></tr>
    <tr><td class="paramname">list</td><td>shift_vector A list of homological shifts in the complex </td></tr>
    <tr><td class="paramname">list</td><td>dimension_vector A list of the number of direct sums of each coherent sheaf in the complex</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>If the sheaf vector is empty </td></tr>
    <tr><td class="paramname">ValueError</td><td>If the sheaf vector and shift vector have different lengths </td></tr>
    <tr><td class="paramname">TypeError</td><td>If any element of the sheaf vector is not a <a class="el" href="namespacesrc_1_1_coherent_sheaf.html">CoherentSheaf</a> object </td></tr>
    <tr><td class="paramname">TypeError</td><td>If any element of the shift vector is not an integer </td></tr>
    <tr><td class="paramname">ValueError</td><td>If the dimension vector is not the same length as the sheaf vector </td></tr>
    <tr><td class="paramname">TypeError</td><td>If any element of the dimension vector is not an integer </td></tr>
    <tr><td class="paramname">ValueError</td><td>If any element of the dimension vector is negative </td></tr>
    <tr><td class="paramname">ValueError</td><td>If the catagory of the sheaves in the complex is not implemented </td></tr>
    <tr><td class="paramname">ValueError</td><td>If the sheaf vector contains objects of different catagories </td></tr>
    <tr><td class="paramname">ValueError</td><td>If the sheaf vector contains objects of different base spaces </td></tr>
    <tr><td class="paramname">ValueError</td><td>If the sheaf vector contains objects of different projective spaces </td></tr>
    <tr><td class="paramname">TypeError</td><td>If the sheaf vector contains objects of different projective spaces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a85e811d0d0ed0e471f7666c51e7a483e" name="a85e811d0d0ed0e471f7666c51e7a483e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e811d0d0ed0e471f7666c51e7a483e">&#9670;&#160;</a></span>__len__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex.__len__ </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The length of the chain complex is the number of sheaves in the complex. </p>
<dl class="section return"><dt>Returns</dt><dd>int The number of sheaves in the complex </dd></dl>

</div>
</div>
<a id="adbfc291368151be74b669b4f2edd9c79" name="adbfc291368151be74b669b4f2edd9c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfc291368151be74b669b4f2edd9c79">&#9670;&#160;</a></span>__str__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex.__str__ </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String representation of the chain complex. </p>
<p>The complex is represented in cohomological order (which technically would be descending order of the shifts, since IR[-2] means the complex with a copy of IR in index 2). The individual coherent sheaves in the complex are represented by their own respective print functinos &mdash; this will generally be cumbersome for arbitrary vector bundles, but more clean for named instances like O(1) or Ω(3).</p>
<dl class="section return"><dt>Returns</dt><dd>str A string representation of the chain complex </dd></dl>

</div>
</div>
<a id="aa0baf08c80270b5ccdf997788aeb1070" name="aa0baf08c80270b5ccdf997788aeb1070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0baf08c80270b5ccdf997788aeb1070">&#9670;&#160;</a></span>_combine_repeats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex._combine_repeats </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to combine repeated sheaves in the complex. </p>
<p>This is useful for simplifying the complex, as we can combine repeated sheaves into a single sheaf with a larger dimension. This function specifically requires the <b>hash</b> implementation for the <a class="el" href="namespacesrc_1_1_coherent_sheaf.html">CoherentSheaf</a> and <a class="el" href="classsrc_1_1_coherent_sheaf_1_1_line_bundle.html" title="Main class for line bundles on a projective variety.">LineBundle</a> objects. </p>

</div>
</div>
<a id="af05e1ce45f86ad32474b98d8a17f7a73" name="af05e1ce45f86ad32474b98d8a17f7a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05e1ce45f86ad32474b98d8a17f7a73">&#9670;&#160;</a></span>_remove_zeros_from_dimension_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex._remove_zeros_from_dimension_vector </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function which iterates through the dimension vector, and if a certain Coherent sheaf is only included 0 times, we may effectively erase it. </p>

</div>
</div>
<a id="a70373ec03d47a5d6dd8e8694186ae138" name="a70373ec03d47a5d6dd8e8694186ae138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70373ec03d47a5d6dd8e8694186ae138">&#9670;&#160;</a></span>central_charge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex.central_charge </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the central charge of the chain complex. </p>
<p>The central charge of a chain complex is the alternating sum of the central charges of the individual sheaves in the complex. Since the central charge is additive, we may multiply the central charges by the dimension of the sheaf to represent direct sums of sheaves. However, most of this functionality is already defined in the <a class="el" href="#a0d7b95df49db36f52234bd8809b6a843" title="Helper function to compute the Chern Character of the chain complex.">chernCharacter()</a> function, so we will simply call that function and then compute the central charge from the Chern Character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>args The arguments required to compute the central charge. The number of arguments and the type of arguments will depend on the catagory of the sheaves in the complex. For P1, the central charge requires a single complex number. For P2, the central charge requires two floating-point numbers. For K3, the central charge requires two floating-point numbers and an integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>complex The central charge of the chain complex as a complex number</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>If the number of arguments is incorrect </td></tr>
    <tr><td class="paramname">TypeError</td><td>If the type of the arguments is incorrect </td></tr>
    <tr><td class="paramname">NotImplementedError</td><td>If the catagory of the sheaves in the complex is not implemented </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html#a181bcb14152a914997c7990b33b51c18">src.DerivedCategoryObject.DerivedCategoryObject</a>.</p>

</div>
</div>
<a id="a0d7b95df49db36f52234bd8809b6a843" name="a0d7b95df49db36f52234bd8809b6a843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7b95df49db36f52234bd8809b6a843">&#9670;&#160;</a></span>chernCharacter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex.chernCharacter </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to compute the Chern Character of the chain complex. </p>
<p>The Chern Character of a chain complex is the alternating sum of the Chern Characters of the individual sheaves in the complex. Since the Chern character is additive, we may multiply the Chern Characters by the dimension of the sheaf to represent direct sums of sheaves.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacesrc_1_1_chern_character.html">ChernCharacter</a> The Chern Character of the chain complex </dd></dl>

<p>Reimplemented from <a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html#a1f4aac18056360d11918b709dc341937">src.DerivedCategoryObject.DerivedCategoryObject</a>.</p>

</div>
</div>
<a id="adc104a639fb1e10753ad4552ba9b1792" name="adc104a639fb1e10753ad4552ba9b1792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc104a639fb1e10753ad4552ba9b1792">&#9670;&#160;</a></span>get_largest_phase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex.get_largest_phase </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to compute the largest phase of the chain complex. </p>
<p>This behaves as a sort of "largest
Harder-Narasimhan factor" for the complex, since Chain complexes will almost never be stable when they have objects in distinct shifts. The phase of an individual element of a chain complex generally requires that object to be stable, so that we typically use LineBundles for our current applications. By definition of a slicing, the shift of each object in the complex should add to the respective phases; thus, this method computes the largest sum of the phase of the sheaf and the shift of the sheaf in the complex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>args The arguments required to compute the phase. The number of arguments and the type of arguments will depend on the catagory of the sheaves in the complex. For P1, the phase requires a single complex number. For P2, the phase requires two floating-point numbers. For K3, the phase requires two floating-point numbers and an integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float The largest phase of the chain complex</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>If the number of arguments is incorrect </td></tr>
    <tr><td class="paramname">TypeError</td><td>If the type of the arguments is incorrect </td></tr>
    <tr><td class="paramname">NotImplementedError</td><td>If the catagory of the sheaves in the complex is not implemented </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36340635bb9a289121eb96778a5b4da3" name="a36340635bb9a289121eb96778a5b4da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36340635bb9a289121eb96778a5b4da3">&#9670;&#160;</a></span>get_smallest_phase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex.get_smallest_phase </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to compute the smallest phase of the chain complex. </p>
<p>This behaves as a sort of "smallest
Harder-Narasimhan factor" for the complex, since Chain complexes will almost never be stable when they have objects in distinct shifts. The phase of an individual element of a chain complex generally requires that object to be stable, so that we typically use LineBundles for our current applications. By definition of a slicing, the shift of each object in the complex should add to the respective phases; thus, this method computes the smallest sum of the phase of the sheaf and the shift of the sheaf in the complex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>args The arguments required to compute the phase. The number of arguments and the type of arguments will depend on the catagory of the sheaves in the complex. For P1, the phase requires a single complex number. For P2, the phase requires two floating-point numbers. For K3, the phase requires two floating-point numbers and an integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float The smallest phase of the chain complex</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>If the number of arguments is incorrect </td></tr>
    <tr><td class="paramname">TypeError</td><td>If the type of the arguments is incorrect </td></tr>
    <tr><td class="paramname">NotImplementedError</td><td>If the catagory of the sheaves in the complex is not implemented </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0ec73042f19e9896f67b2a1724928d7" name="ab0ec73042f19e9896f67b2a1724928d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ec73042f19e9896f67b2a1724928d7">&#9670;&#160;</a></span>is_semistable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex.is_semistable </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to compute whether the chain complex is semistable. </p>
<p>This almost never occurs, since if the complex contains two or more stable objects of distinct phase, it will never be stable. For example, suppose E2 is a stable subobject of maximum phase and E1 is another stable object with strictly smaller phase. Then </p><pre class="fragment">      E2 ----&gt; Complex ------&gt; Cone
</pre><p>will destabilize the complex, and Cone will be nontrivial since it has a non-zero map to E1. The easiest way to check that the complex is concentrated in only a single phase is to compare its largest and smallest phases from the previous methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>args The arguments required to compute the phase. The number of arguments and the type of arguments will depend on the catagory of the sheaves in the complex. For P1, the phase requires a single complex number. For P2, the phase requires two floating-point numbers. For K3, the phase requires two floating-point numbers and an integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the chain complex is semistable, False otherwise</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>If the number of arguments is incorrect </td></tr>
    <tr><td class="paramname">TypeError</td><td>If the type of the arguments is incorrect </td></tr>
    <tr><td class="paramname">NotImplementedError</td><td>If the catagory of the sheaves in the complex is not implemented </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html#a95bc29833249e58a920c3454110125d2">src.DerivedCategoryObject.DerivedCategoryObject</a>.</p>

</div>
</div>
<a id="a6fb46ca115fc7fef97f7f4676a74cfe8" name="a6fb46ca115fc7fef97f7f4676a74cfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb46ca115fc7fef97f7f4676a74cfe8">&#9670;&#160;</a></span>isShiftOfSheaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex.isShiftOfSheaf </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple helper function which checks if the complex is a shift of a single sheaf. </p>
<dl class="section return"><dt>Returns</dt><dd>bool True if the complex is a shift of a single sheaf, False otherwise </dd></dl>

</div>
</div>
<a id="a06ddcc7b614880bd8889c944f76237ee" name="a06ddcc7b614880bd8889c944f76237ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ddcc7b614880bd8889c944f76237ee">&#9670;&#160;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex.shift </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to shift the chain complex by a given homological shift. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>shift The homological shift to apply to the chain complex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classsrc_1_1_chain_complex_1_1_chain_complex.html" title="For any abelian category, a chain complex is a sequence of objects and morphisms between them such th...">ChainComplex</a> The chain complex shifted by the homological shift </dd></dl>

<p>Reimplemented from <a class="el" href="classsrc_1_1_derived_category_object_1_1_derived_category_object.html#a6c1dfa5772ffeae4bf5f1e6a7a2de496">src.DerivedCategoryObject.DerivedCategoryObject</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6373f5a40572d1c1b76bfb3e0b0bf40c" name="a6373f5a40572d1c1b76bfb3e0b0bf40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6373f5a40572d1c1b76bfb3e0b0bf40c">&#9670;&#160;</a></span>dimension_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex.dimension_vector = dimension_vector</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of the number of direct sums of each coherent sheaf in the complex. </p>

</div>
</div>
<a id="a864ac31fa0d9fe9a4c50f803cc6023b8" name="a864ac31fa0d9fe9a4c50f803cc6023b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864ac31fa0d9fe9a4c50f803cc6023b8">&#9670;&#160;</a></span>sheaf_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex.sheaf_vector = sheaf_vector</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of coherent sheaves in the complex, so that the chain complex can operate similar to a DenseVector. </p>

</div>
</div>
<a id="ad30a876c85094c7347ea6180fb058171" name="ad30a876c85094c7347ea6180fb058171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30a876c85094c7347ea6180fb058171">&#9670;&#160;</a></span>shift_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.ChainComplex.ChainComplex.shift_vector = shift_vector</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of homological shifts in the complex. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_chain_complex_8py.html">ChainComplex.py</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesrc.html">src</a></li><li class="navelem"><a class="el" href="namespacesrc_1_1_chain_complex.html">ChainComplex</a></li><li class="navelem"><a class="el" href="classsrc_1_1_chain_complex_1_1_chain_complex.html">ChainComplex</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
